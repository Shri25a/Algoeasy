<!doctype html>
<html lang="en">
  <head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="static/index.css" />
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
    <link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Libre+Bodoni&display=swap" rel="stylesheet"> 
<link
      rel="stylesheet"
      href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css"/>
    <link rel="stylesheet" href="test.css">

    <title>TRAVERSEL</title>
    <script src="bubblesort.js"></script>
  </head>
  <body style="background:linear-gradient(to right,#ebe8e8,#b6e7cf) ">
    <nav class="navbar navbar-expand-md navbar-light fixed-top ">
      <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarTogglerDemo03" aria-controls="navbarTogglerDemo03" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
      </button>
      
    
      <div class="collapse navbar-collapse" id="navbarTogglerDemo03"style="background-color: rgb(183, 242, 205);">
        <ul class="navbar-nav mr-auto mt-2 mt-lg-0">
          <li class="nav-item active">
            <a class="nav-link" href="Home.html">Home <span class="sr-only">(current)</span></a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="Sorts.html">Sort</a>
          </li>
          <li class="nav-item">
            <a class="nav-link " href="stack.html">Stacks</a>
          </li>
          <li class="nav-item">
            <a class="nav-link " href="linkedlist/linkedlist.html">linked list</a>
          </li>
          <li class="nav-item">
            <a class="nav-link " href="/graphs/graphs.html">Graphs</a>
          </li>
          <li class="nav-item">
            <a class="nav-link " href="Tree/tree.html">Tree</a>
          </li>
        </ul>
        
      </div>
    </nav>
      
      <div class="outer">
        <div class="left">
          <div class="data">
            <h2 style="font-family: cursive;margin-top: 4%;margin-left: 3%;margin-right: 3%;">TREE TRAVERSEL</h2>
      <p style="font-family: cursive;margin-top: 4%;margin-left: 3%;margin-right: 3%;">Traversal is a process to visit all the nodes of a tree and may print their values too. Because, all nodes are connected via edges (links) we always start from the root (head) node. That is, we cannot randomly access a node in a tree. There are three ways which we use to traverse a tree −</p><br>
      <a href="#inorder">INORDER</a><br>
        <a href="#preorder">PREORDER</a><br>
        <a href="#postorder">POSTORDER</a><br>
        <a href="#level">LEVEL</a><br>

        <div id="inorder">
          <h2 style="font-family: cursive;margin-top: 4%;margin-left: 3%;margin-right: 3%;"> Inorder traversel</h2>
          <p style="font-family: cursive;margin-top: 4%;margin-left: 3%;margin-right: 3%;">In this traversal method, the left subtree is visited first, then the root and later the right sub-tree. We should always remember that every node may represent a subtree itself.

            If a binary tree is traversed in-order, the output will produce sorted key values in an ascending order.</p>
            <img src="/shri/In-order_Traversal.jpg" width="60%"><br>
            <p style="font-family: cursive;margin-top: 4%;margin-left: 3%;margin-right: 3%;">
              We start from A, and following in-order traversal, we move to its left subtree B.B is also traversed in-order. The process goes on until all the nodes are visited. The output of in-order traversal of this tree will be −<br>

                  D → B → E → A → F → C → G<br>
            </p>
            <h3 style="font-family: cursive;margin-top: 4%;margin-left: 3%;margin-right: 3%;">Algorithm</h3>
            Until all nodes are traversed −<br>

              Step 1 − Recursively traverse left subtree.<br>

              Step 2 − Visit root node.<br>

              Step 3 − Recursively traverse right subtree<br>
        </div>
        <div id="preorder">
          <h2 style="font-family: cursive;margin-top: 4%;margin-left: 3%;margin-right: 3%;"> Preorder traversel</h2>
          <p>In this traversal method, the root node is visited first, then the left subtree and finally the right subtree.</p>
            <img src="/shri/Pre-order_Traversal.jpg" width="60%"><br>
            <p style="font-family: cursive;margin-top: 4%;margin-left: 3%;margin-right: 3%;">
              We start from A, and following pre-order traversal, we first visit A itself and then move to its left subtree B. B is also traversed pre-order. The process goes on until all the nodes are visited. The output of pre-order traversal of this tree will be −<br>

              A → B → D → E → C → F → G<br>
            </p style="font-family: cursive;margin-top: 4%;margin-left: 3%;margin-right: 3%;">
            <h3 style="font-family: cursive;margin-top: 4%;margin-left: 3%;margin-right: 3%;">Algorithm</h3>
            Until all nodes are traversed −<br>
            Step 1 − Visit root node.<br>

              Step 2 − Recursively traverse left subtree.<br>

              Step 3 − Recursively traverse right subtree<br>
        </div>
        <div id="postorder">
          <h2 style="font-family: cursive;margin-top: 4%;margin-left: 3%;margin-right: 3%;"> Postorder traversel</h2>
          <p>In this traversal method, the root node is visited last, hence the name. First we traverse the left subtree, then the right subtree and finally the root node..</p>
            <img src="/shri/Post-order_Traversal.jpg" width="60%"><br>
            <p>
              We start from A, and following pre-order traversal, we first visit the left subtree B. B is also traversed post-order. The process goes on until all the nodes are visited. The output of post-order traversal of this tree will be −<br>
              D → E → B → F → G → C → A<br>
            </p>
            <h3 style="font-family: cursive;margin-top: 4%;margin-left: 3%;margin-right: 3%;">Algorithm</h3>
            Until all nodes are traversed −<br>

              Step 1 − Recursively traverse left subtree.<br>

              Step 2 − Recursively traverse right subtree<br>

              Step 2 − Visit root node.<br>
        </div>
        <div id="level">
          <h2 style="font-family: cursive;margin-top: 4%;margin-left: 3%;margin-right: 3%;"> Level wise traversel</h2>
          <p style="font-family: cursive;margin-top: 4%;margin-left: 3%;margin-right: 3%;">The breadth first traversal of a binary tree is also known as the level order traversal of a binary tree in Java.

            For the following binary tree:
            The level order traversal is: 18 20 30 60 34 45 65 12 50 98 82 31 59 71 41</p>
            <img src="/shri/level-order-traversal-of-a-binary-tree-in-java.png" width="30%">
            <h3>Algorithm</h3>
            <pre>
              displayLevelorder(tree)  
              1) Create a queue that is empty. Let's say the queue is que  
              2) tNode = r // starting from the root  
              3) Iterate until the tNode is not NULL  
                  a) display the tNode->val.  
                  b) enqueue the children of the tNode  
                    (First the left child and then the right child) into que  
                  c) A node n is then dequeue from the queue (que) 
            </pre>
        </div>
                </div></div>
        <div class="right">
          <div class="calculate" style="font-size: 1rem;width: 100%;">
            <h2 style="font-family: cursive;margin-top: 4%;margin-left: 3%;margin-right: 3%;">IMPLEMENTATION</h2>
            <h3>level order</h3>
            <pre>
              /**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> ans;
        queue<pair<TreeNode*,int>> q;
        if(root==NULL){
            return ans;
        }
        pair pr = make_pair(root,0);
        int level=1;
        q.push(pr);
        vector<int> vec;
        while(!q.empty()){
            TreeNode*temp=q.front().first;
            int currlevel=q.front().second;
            
            if(temp->left!=NULL){
                pair p = make_pair(temp->left,level);
                q.push(p);
            }
            if(temp->right!=NULL){
                pair p = make_pair(temp->right,level);
                q.push(p);
            }
            vec.push_back(q.front().first->val);
            q.pop();

            if(q.front().second!=currlevel){
                level++;
                ans.push_back(vec);
                vec.clear();
                vector<int> vec;
            }
        }
        return ans;
    }
};
            </pre>
            <h3>Inorder</h3>
            <pre>void printInorder(struct Node* node)
              {
                  if (node == NULL)
                      return;
               
                  // First recur on left child
                  printInorder(node->left);
               
                  // Then print the data of node
                  cout node->data  " ";
               
                  // Now recur on right child
                  printInorder(node->right);
              }</pre>
            <h3>Preorder</h3>
            <pre>void printPreorder(struct Node* node)
              {
                  if (node == NULL)
                      return;
               
                  // First print data of node
                  cout node->data  " ";
               
                  // Then recur on left subtree
                  printPreorder(node->left);
               
                  // Now recur on right subtree
                  printPreorder(node->right);
              }</pre>
            <h3>Postorder</h3>
            <pre>void printPostorder(struct Node* node)
              {
                  if (node == NULL)
                      return;
               
                  // First recur on left subtree
                  printPostorder(node->left);
               
                  // Then recur on right subtree
                  printPostorder(node->right);
               
                  // Now deal with the node
                  cout << node->data << " ";
              }</pre>
            </div>
        <div id="demo1"></div>
            </div>
      </div>
            
          </div>
        </div>
      </div>
      
    </body>
</html>