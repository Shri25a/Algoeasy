<!doctype html>
<html lang="en">
  <head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="static/index.css" />
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
    <link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Libre+Bodoni&display=swap" rel="stylesheet"> 
<link
      rel="stylesheet"
      href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css"/>
    <link rel="stylesheet" href="test.css">

    <title>STACK</title>
    <script src="countsort.js"></script>
  </head>
  <body style="background:linear-gradient(to right,#ebe8e8,#b6e7cf) ">
    <nav class="navbar navbar-expand-md navbar-light fixed-top ">
      <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarTogglerDemo03" aria-controls="navbarTogglerDemo03" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
      </button>
      
    
      <div class="collapse navbar-collapse" id="navbarTogglerDemo03"style="background-color: rgb(183, 242, 205);">
        <ul class="navbar-nav mr-auto mt-2 mt-lg-0">
          <li class="nav-item active">
            <a class="nav-link" href="Home.html">Home <span class="sr-only">(current)</span></a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="Sorts.html">Sort</a>
          </li>
          <li class="nav-item">
            <a class="nav-link " href="stack.html">Stacks</a>
          </li>
          <li class="nav-item">
            <a class="nav-link " href="linkedlist/linkedlist.html">linked list</a>
          </li>
          <li class="nav-item">
            <a class="nav-link " href="/graphs/graphs.html">Graphs</a>
          </li>
          <li class="nav-item">
            <a class="nav-link " href="Tree/tree.htmls">Tree</a>
          </li>
        </ul>
        
      </div>
    </nav>
      </div>
      <div class="outer">
        <div class="left">
          <div class="data">
            <h2>STACK</h2>
            <p>A Stack is a linear data structure that follows the LIFO (Last-In-First-Out) principle. Stack has one end, whereas the Queue has two ends (front and rear). It contains only one pointer top pointer pointing to the topmost element of the stack. Whenever an element is added in the stack, it is added on the top of the stack, and the element can be deleted only from the stack. In other words, a stack can be defined as a container in which insertion and deletion can be done from the one end known as the top of the stack.</p>
            <h3>WORKING OF STACK</h3>
            <p>Stack works on the LIFO pattern. As we can observe in the below figure there are five memory blocks in the stack; therefore, the size of the stack is 5.

              Suppose we want to store the elements in a stack and let's assume that stack is empty. We have taken the stack of size 5 as shown below in which we are pushing the elements one by one until the stack becomes full.</p>
              <img src="/shri/ds-stack.png" alt="">
              <p>Since our stack is full as the size of the stack is 5. In the above cases, we can observe that it goes from the top to the bottom when we were entering the new element in the stack. The stack gets filled up from the bottom to the top.</p><br>
              <p>Standard Stack Operations<br>
                The following are some common operations implemented on the stack:<br>
                
                push(): When we insert an element in a stack then the operation is known as a push. If the stack is full then the overflow condition occurs.<br>
                pop(): When we delete an element from the stack, the operation is known as a pop. If the stack is empty means that no element exists in the stack, this state is known as an underflow state.<br>
                isEmpty(): It determines whether the stack is empty or not.<br>
                isFull(): It determines whether the stack is full or not.'<br>
                peek(): It returns the element at the given position.<br>
                count(): It returns the total number of elements available in a stack.<br>
                change(): It changes the element at the given position.<br>
                display(): It prints all the elements available in the stack.</p>
                <br><br>
                <h3>APPLICATIONS OF STACK</h3>
                <p>1)Function calls and recursion: When a function is called, the current state of the program is pushed onto the stack. When the function returns, the state is popped from the stack to resume the previous function’s execution.<br>
                  2)Undo/Redo operations: The undo-redo feature in various applications uses stacks to keep track of the previous actions. Each time an action is performed, it is pushed onto the stack. To undo the action, the top element of the stack is popped, and the reverse operation is performed.<br>
                  3)Expression evaluation: Stack data structure is used to evaluate expressions in infix, postfix, and prefix notations. Operators and operands are pushed onto the stack, and operations are performed based on the stack’s top elements.<br>
                  4)Browser history: Web browsers use stacks to keep track of the web pages you visit. Each time you visit a new page, the URL is pushed onto the stack, and when you hit the back button, the previous URL is popped from the stack.<br>
                  5)Balanced Parentheses: Stack data structure is used to check if parentheses are balanced or not. An opening parenthesis is pushed onto the stack, and a closing parenthesis is popped from the 6)stack. If the stack is empty at the end of the expression, the parentheses are balanced.<br>
                  Backtracking Algorithms: The backtracking algorithm uses stacks to keep track of the states of the problem-solving process. The current state is pushed onto the stack, and when the algorithm backtracks, the previous state is popped from the stack.<br></p>
              </div></div>
        <div class="right">
          <div class="calculate">
            <h2>IMPLEMENATION</h2>
            <h3>USING ARRAY</h3>
            <pre>
              #include <bits/stdc++.h>
using namespace std;

class stackarray{
    public:
    int top1=0;
    int arr[100];
    void push(int x){
        if(top1<100 && top1>=-1){
            arr[top1]=x;
            top1++;
        }
        else{
            cout"stack overflow";
        }
    }
    void pop(){
        if(top1>=0){
            arr[top1]=-1;
            top1--;
        }
        else{
            cout"stack overflow";
        }
    }
    bool isempty(){
        if(top1==0){
            return true;
        }
        return false;
    }
    void topsatck(){
        if(top1>=0){
            coutarr[top1]endl;
        }
        else{
            cout"stack is emty";
        }
    }

};
int main(){
    stackarray st;
    st.push(23);
    st.push(34);
    st.push(90);
    st.pop();
    st.topsatck();
    st.isempty();
    return 0;
}
                </pre>
                <h3>USING LINKED LIST</h3>
                <pre>
                  #include <bits/stdc++.h>
                  using namespace std;
                  
                  
                  class Node {
                  public:
                    int data;
                    Node* link;
                  
                    Node(int n)
                    {
                      this->data = n;
                      this->link = NULL;
                    }
                  };
                  
                  class Stack {
                    Node* top;
                  
                  public:
                    Stack() { top = NULL; }
                  
                    void push(int data)
                    {
                  
                      Node* temp = new Node(data);
                  
                  
                      if (!temp) {
                        cout << "\nStack Overflow";
                        exit(1);
                      }
                      temp->data = data;
                      temp->link = top;
                      top = temp;
                    }
                  
                    bool isEmpty()
                    {
                      return top == NULL;
                    }
                  
                    int peek()
                    {
                      if (!isEmpty())
                        return top->data;
                      else
                        exit(1);
                    }
                  
                    void pop()
                    {
                      Node* temp;
                      if (top == NULL) {
                        cout << "\nStack Underflow" << endl;
                        exit(1);
                      }
                      else {
                        temp = top;
                        top = top->link;
                        free(temp);
                      }
                    }
                  
                    void display()
                    {
                      Node* temp;
                  
                      if (top == NULL) {
                        cout << "\nStack Underflow";
                        exit(1);
                      }
                      else {
                        temp = top;
                        while (temp != NULL) {
                  
                          cout << temp->data;
                  
                    
                          temp = temp->link;
                          if (temp != NULL)
                            cout << " -> ";
                        }
                      }
                    }
                  };
                  
                  int main()
                  {
                    Stack s;
                  
                    s.push(11);
                    s.push(22);
                    s.push(33);
                    s.push(44);
                  
                  
                    s.display();
                  
                    cout << "\nTop element is " << s.peek() << endl;
                  
                    s.pop();
                    s.pop();
                  
                  
                    s.display();
                  
                    cout << "\nTop element is " << s.peek() << endl;
                  
                    return 0;
                  }
                  </pre>
        <div id="demo1"></div>
            </div>
      </div>
            
          </div>
        </div>
      </div>
     
    
    </body>
</html>